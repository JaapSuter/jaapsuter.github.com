\documentclass[twocolumn]{paper}
\begin{document}

\title{Lessons From Boost}
\author{Jaap Suter}
\maketitle

\begin{abstract}
The C++ Boost Libraries \cite{bib:boost} are generally considered
industrial strength implementations of modern C++ idioms at an
unsurpassed quality. I have long been a proponent of Boost use and
still consider the collection of libraries to achieve a level of
excellence that all software engineers should strive for.

That said, through my experience in using Boost and my involvement
in the Boost community I have learned that it does not always
provide an end-all solution that works in the constraints the game
industry faces.

This article discusses some lessons we can take from Boost, both
good and bad. It does not yet explain how we might take these
lessons and apply them within Electronic Arts. This is discussed in
another article.
\end{abstract}

\section{Introduction}

I have used Boost since early 2001 and have extensive experience
with at least thirty percent of the libraries in it and familiarity
with at least eighty percent.

Shortly after coming to work for EA I tried to get other people
enthusiastic about this free technology. I was involved in the
discussions that eventually led to the development of the Boost
License that made adoption at EA substantially easier. I wrote two
articles and many emails trying to convince people to have a look at
Boost.

Four years ago Boost was in better shape than it is today. It's
rapid growth has led to a monolithic entity that has several flaws
that hinder its use within EA. I am much less enthusiastic about
Boost than I once was, although I am still convinced it should be
used as a powerful source of inspiration. If we keep our eyes open
to some of the flaws outlined below, we can reap the benefits that
Boost offers and avoid its pitfalls.

Obviously many of these lessons can be learned from other projects
and more general software engineering practices. Boost provides a
great example because it is C++ oriented, focuses on library design
and implementation as opposed to application development, and does
many things the right way already.

\section{The Good}

Boost has a lot of great things to offer. Not necessarily in the
form of actual technology we can download and use, but certainly by
looking at their processes and development style.

\subsection{Pride and Care}

The two main factors that lead to the quality that Boost lays claim
on is the pride and care the Boost developers take in their work.

Whenever a bug is reported or a feature request is made, library
authors will go above and beyond to help that person out. Extensive
emails trying to recreate a bug locally or defending the rationale
for library design decisions not only provide great help in that
particular situation, but they contribute to an image that Boost is
here to help you, not just to write cool self-serving technology.

Once Boost got a reputation for being of such high quality and
caring about its customer base, getting a library accepted into
Boost became a prestigious feat. Existing Boost developers prided
themselves in having contributed to the collection and they were
going to make sure that new contributions and new authors were held
up to the same standards that they were held to.

In a sense it has created somewhat of an elitist environment in
which people feel privileged they are allowed to participate in
Boost development, amidst the great names of C++ development; the
very people that are on the standardization committee. Obviously
such an elitist attitude comes with certain risks, but in the Boost
case it has worked well for the most part.

\subsection{Community}

There is an incredibly strong sense of community in Boost. Everybody
feels involved in the decision making process and design phase. Not
just Boost library developers but all clients just as much. The
consequence is that getting buy in from customers is simplified
since they have been a part of the entire process.

There are two main reasons for this involvement in and with the
community.

\subsubsection{Transparency}
There are no hidden processes, anonymous people or unknown
organizations behind Boost. All work that is done to improve Boost
is out in the open and can be scrutinized by anybody who is keen on
doing so. This honesty helps creates trust and provides the
background for the decision making process within Boost, especially
when it comes to priorities.

\subsubsection{Cross Pollination}

Instead of having one mailing list per library, Boost only uses a
small amount of mailing lists that cover large areas of interest.
The result is that people whose main interest is in library A also
run across messages from library B. They might not treat these
messages with the same diligence as the ones for library A, but with
sufficient time and motivation they'll skim over all messages and
speak up when they feel there is a need.

This ties in with the transparency, meaning that no messages go
unnoticed and the entire decision making process for each piece of
technology is always available, even to those that might not be
primary stakeholder.

\subsection{Formal Reviews}

For a library to become part of Boost it has to go through a formal
review process \cite{bib:formal review}. This process is the last
layer of quality control before a library is turned from a freeware
amateur project into something that is held up to Boost standards.
It is not uncommon for a library to fail formal review process and
be sent back to the drawing board for significant changes.

Obviously a library proposal undergoes an extensive informal design
and implementation process before it is submitted for a formal
review. Nevertheless, having strict rules on how to manage the last
checkpoint before a library becomes available under the Boost name
is what allowed Boost to maintain such a high quality.

\subsection{Testing}

The Boost libraries come with the most impressive tests I have had
the pleasure of working with. I strongly recommend having a look at
the continuous regression test output \cite{bib:regression output}
and browsing around to see how much coverage the Boost tests
provide.

Their tests are fully automated, provide an unsurpassed coverage
(they even have tests that are supposed to fail compilation or
linking, and fail if the compiler accepts it), and give a level of
confidence in the continued stability of the codebase that is
unattainable without such tests.

\subsection{Documentation}

All Boost libraries come with a large amount of documentation. And
more importantly, the documentation is relevant and useful. Many
projects outside of Boost only generate Doxygen-style documentation
that is extracted from comments like the following

\texttt{\\
void Scene::Render(); // Renders the scene \\
void Vector::SetX(); // Sets X component}

These type of comments are rarely useful. While the generated
reference documentation looks very impressive, nobody uses it and
the source is littered with comments that really only express what
the code already expressed succinctly.

Boost offers full tutorials, design rationales, FAQs, etcetera. All
documentation is aimed to make libraries easy to use for the client
and justify the decision making process.

\subsection{Technology}

As mentioned above, the number of libraries in Boost has grown at
perhaps too fast a rate. The current situation is that only a subset
of Boost libraries can be considered absolutely crucial to
contemporary C++ development and the rest of the libraries range
from too C++ savy, modern and template hungry to very esoteric and
only useful in very specific domains.

Coincidentally, the C++ standardization committee has been working
towards a new C++ standard and as part of that they are releasing
several intermediate non-normative technical reports \cite{bib:tr1}.
These offer premature versions of what might be additions to the
standard library when the new version is agreed upon.

Fortunately for us, the suggested components for the so-called TR1
contain those libraries of Boost that are generally considered
mandatory for modern C++ programming. We should therefore heed the
work that is being done on the TR1. Not only because these libraries
make sense today, but also because the C++ programmers of tomorrow
will be intimately familiar with their use the day they enter the EA
office.

What follows are three technologies I would recommend to any
software engineer. They provide a good introductory level from more
old school styles of C++ programming and have proven without a doubt
that they enable the implementation of idioms, patterns and design
in ways that traditional C and C++ do not allow.

Whether or not we provide our own implementation of these
technologies, use a vendor supplied TR1 implementation, or end up
using the Boost version is not discussed here, nor do I go into
great detail on why these technologies are crucial to enable better
library development. This will be discussed in a different article.

\subsubsection{Smart Pointers}

Smart pointers have been around in some form or another for many
years, but it has only been a few years that the C++ community has
realized that the term smart pointer encompasses a broad range of
different usage and implementation strategies. Largely thanks to COM
programming, many people's first thought when they hear smart
pointer is an intrusive reference counted smart pointer. However,
there are such things as non-intrusive reference counted smart
pointers, reference linked smart pointers, scoped smart pointers,
locked smart pointers, weak pointers, etcetera, etcetera.

Through the evolution of different smart pointer designs, three
recurring types of smart pointers have emerged,
\texttt{boost::scoped\_ptr}, \texttt{boost::shared\_ptr} and
\texttt{boost::weak\_ptr} offer a versatility that makes programs
not only more robust but also more flexible. Especially the power of
weak pointers in observer and visitor patterns cannot be
underestimated.

\subsubsection{Generic Callbacks}

Callbacks offer a great way to decouple systems and reduce
dependencies. Unfortunately, unlike in C, C++ has greatly
complicated the different types of callable entities from just free
functions, to free functions, member functions and functors. To
still enable and encourage the use of callbacks, we need a powerful
generic callback library. C\# recognizes the same need and provides
a limited version of this technology built into the language through
delegates.

Generic callback implementations have gone through a significant
evolution. Andreis Alexandrescus implementation in his book Modern
C++ Design was one the first to become popular but since then they
have crept up in many places. Boost provides a solution in the form
of \texttt{boost::function} and it is this interface that is
proposed for the TR1.

I strongly recommend adhering to the TR1 interface, but looking into
a fast delegate implementation to improve their performance.
Furthermore, generic callbacks need to come with at least a minimal
form of generic binding to facilitate member functions as callbacks.
Boost offers the \texttt{boost::bind} library which is very powerful
and easy to use, but its scope might be beyond our needs and its
effect on performance are too implicit and severe to be considered
as a good solution.

\subsubsection{Signals and Slots}

Often building on top of a generic callback, a signal and slots
library enables another series of event based patterns that makes
decoupling systems significantly easier. TR1 will offer a signal and
slots library modeled after a blend of \texttt{boost::signals} and
the stand alone libsigc++ \cite{bib:libsigc++} library.

\section{The Bad}

From the all the good things mentioned above, one might think that
Boost offers perfect solutions. At one point they were fairly close
but with popularity come growing pains and the flaws are exposed.

Most of Boost's problems stem from two fundamental issues:
\begin{itemize}
    \item Library authors have a tendency to only concern themselves with platforms that
    have virtual memory and are not particularly susceptible to
    fragmentation issues (e.g. PC). This leaves embedded systems and console
    developers behind, even on next generation consoles which still
    provide very primitive memory access mechanisms.
    \item Too much work is being done from within an academic environment, and
    not enough use is made on large scale C++ projects.
\end{itemize}

These two issues lead to the following problems with Boost.

\subsection{Level of C++ Use}

The general level of C++ used in Boost is far above and beyond what
today's average C++ programmer are comfortable with. One may argue
that this is more the author's concern than the user's, but it just
so happens that unintended use ends up with cryptic error messages
pointing into PhD. level C++ code or, admittedly much rarer, causes
hard to debug access violations.

Boost technology enables modern C++ idioms that most programmers are
not comfortable with yet. This is a great obstacle to proper Boost
use and often Boost will end up getting the blame for a problem that
actually lies with faulty use of a library.

One might at first consider blaming the user of the library, but the
bottom line is that we should care more about the user than our
ability to deploy the most advanced and elite libraries. While some
of us may enjoy the power of angle brackets and revel in the power
that template meta programming offers, the times when such
techniques are necessary are rare.

\subsection{Compile Times}

The aforementioned academic use of C++ and the preference to reuse
existing code within Boost (introducing inter library dependencies)
results in translation units that consist of many lines of code and
template expressions that modern compilers are not yet made to
handle. This puts a stress on the compiler that leads to build times
far above any acceptable norm.

Minimal build times are absolutely crucial to a programmer's
productivity. Whenever a build induces a task switch, the programmer
not only loses the time he spends in the other task but he also
drops out of the zone in which he programs most effectively.

Build times are an extensive topic discussed in another article. As
far as Boost goes, we need to recognize that in our industry the
trade-off between higher levels of abstraction and faster builds is
occasionally decided in favour of build times.

\subsection{Memory Use}

Many Boost developers consider the PC as their sole target platform.
Today's PCs are rather forgiving when it comes to ineffective memory
access patterns thanks to virtual memory. They also commonly have
more memory available. When technology is built with this in mind is
taken to systems with stricter memory architectures, the result is a
higher risk of running out of memory and much worse; heavy
fragmentation.

Things wouldn't be so bad if Boost libraries exposed a common way to
configure memory allocations. Some libraries do, but it's non
consistent and the libraries we particularly care about do not offer
such a customization.

Even on next generation consoles it is still absolutely mandatory we
have fine-grained control over allocation patterns. Unless we tweak
Boost ourselves (a non trivial task) it will not give us that
control.

\subsection{Performance}

Performance is not always on top of the priority list for Boost
developers. And rightfully so; the majority of Boost users are not
working on performance sensitive software and more so, as Hoare
said; premature optimization is the root of all evil.

Certainly correctness and ease-of-use should often be higher on the
priority list. However, Boost often puts a third requirement over
performance. Namely; genericity.

In the quest for the highest abstraction and the most generic
libraries Boost often sacrifices performance, something the games
industry can't always afford.

It is fair to point out that Boost is always open about performance
guarantees and it is often the particular use of a library that
causes problems. However, as mentioned above when discussing the
level of C++ that Boost uses, we can't always assume our clients
will take the time to fully understand the constraints in which our
technology can work effectively. That means we occasionally have to
use lower abstractions, thereby potentially limiting client use, for
the sake of performance.

\subsection{Concurrency}

C++ as a whole is a rather concurrency agnostic language. It has no
built-in features (even \texttt{volatile} provides no interleaving
guarantees) to cope with threading and the available libraries tend
to be primitive compared to what other languages offer.

Boost tries to improve on the situation, but as with their approach
to memory management, it is done in an inconsistent manner and
different libraries take different approaches.

The most obvious sign of trouble is the complete thread safety of
\texttt{boost::shared\_ptr} meaning that whenever a copy of a
pointer is made the reference count structure is locked and
incremented. Obviously this creates an incredible performance issue
for those \texttt{shared\_ptr}s that are only used within a single
thread.

Given that our next generation platforms are all highly
parallelized, we need fine-grained control over the concurrency
guarantees and features our technology offers.

\subsection{Error Handling}

Boost libraries offer little in the way of a consistent error
handling scheme. It is generally accepted that asserts are used for
invariant violations and exceptions for problems the user might
face, but there is no consistent use of a single assert macro nor a
single well defined exception hierarchy.

Furthermore, exception handling is still a performance trade-off few
game teams are willing to make. Some game developers are beginning
to use exception handling in debug only builds, but enabling it for
release builds it not an option yet. We need different strategies to
deal with problems, and preferably a consistent one.

\section{Conclusion}

Boost has done many things right. The pride they take in their
products and the transparency they offer is one of its greatest
strengths. Their level of testing and documentation offers a quality
that few other libraries can compete with.

Unfortunately, Boost is often too advanced for most programmers at
EA and it is too focused on PC development, neglecting the
performance requirements of embedded systems developers.

We can definitely learn a few things from their processes and
testing strategies. Furthermore, we need to take a strong look at
what the C++ Technical Report \cite{bib:tr1} is offering and come up
with a best way to leverage this technology.

Specific suggestion on applying the above lessons to our situation
at EA are discussed in another article.

\begin{thebibliography}{99}

\bibitem{bib:boost}
    Boost C++ Libraries\\ \emph{http://www.boost.org}
\bibitem{bib:formal review}
    Boost Formal Reviews\\ \emph{http://www.boost.org/more/formal\_review\_process.htm}
\bibitem{bib:regression output}
    Boost Regression Output\\ \emph{http://tinyurl.com/a8l64}
\bibitem{bib:libsigc++}
    libsigc++\\ \emph{http://libsigc.sourceforge.net/}
\bibitem{bib:tr1}
    C++ Standard, Technical Report 1 (TR1)\\
    \emph{http://tinyurl.com/979on}

\end{thebibliography}


\end{document}
