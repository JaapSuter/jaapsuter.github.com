---
layout: post
title: "Computer Science Education"
tags: [Personal, Technical]
---

A commercial disinterest in research is a thing of the past. Corporate funding of university programs is becoming more accepted every day, simply because government budgets are not capable of providing sufficient support. Though a discussion about the government's policy towards education is interesting, I've come to accept that university curricula are no longer defined by universities alone. If we want our students to become corporate-ready IT money makers, instead of letting them study the science of computation, so be it. However, one can only remove a certain amount of fundamental skills and concepts from a teaching program without undermining it. The recent removal of functional programming as a mandatory module in the computer science curriculum at the University of Twente is not only ridiculous, but it finally reveals what seems to be the primary motivation of computer science programs. 

I've long been complaining about the lack of decent programming education at the university I attend. While I can't speak for other universities, my contacts with students worldwide, lead me to believe that it's not better elsewhere. The usual reply states that programming is just an instrument to achieve certain goals. It is then said that university people specify the goals, after which people with lower forms of education are left to do the dirty programming job. There are two fallacies in this stubborn idea. 

Before I will explain this, we have to consider what computer science does. Simply put, computer science is the study of computation. The fundamental concept of any computation is the algorithm. Algorithms transform data into other data. Software is a collection of algorithms, but writing out a complex division is executing an algorithm too. Heck, the addition of two and two is an algorithm. While the study of abstract data representations is fairly reasonable on our faculty, it is the study of algorithms that is lacking. This is a consequence of its contempt for programming. 

Programming is often mistaken for typing huge amounts of text in some obscure language. Even though most real-life programming comes down to this, in essence programming is the act of writing an algorithm. Be it in Pascal, Miranda, some mathematical notation or plain English, it is still programming. 

Now returning tot the first misconception of contemporary computer science education, saying that programming is only an instrument. If computer science is about the study of computation, computations are done by algorithms, and algorithms are written through programming, we must study programming in order to say anything about any computation at all. Not knowing programming is like studying ancient literature while unfamiliar with concepts like nouns and verbs. Taking this analogy further we could say that different languages are the actual instruments. One could write a thriller in English, Dutch or Spanish, but the concepts of language (nouns, verbs, etc.) still apply. Here lies the fault. Programming itself is not the instrument, the method of programming we choose is the instrument. The underlying programming concepts have nothing to do with any language. This brings us to the second misunderstanding. 

Because of this general loathing for programming, we are led to believe that we only need to specify the goals, after which somebody else can realise it. A bricklayer can do some decent masonry when an architect tells him to build a wall, but if the architect doesn't know the concepts of vertical structures, I'm afraid the building wouldn't last very long. That is why software development leadership requires a thorough understanding of all concepts involved. I've seen freshly graduated computer science Masters being outperformed in design, specification and implementation by young self-taught university dropouts. While the dropout's low-level experience taught him all things about high-level designs, what has the Master of Science done in his five years of college? 

This would be a good time to point out that a computer science degree is not worthless. A solid mathematical foundation, knowledge on computing architectures, and some interesting theories about data representations are invaluable assets when it comes to software development. But without the means to implement ideas, what use is science? 

A generation of computer scientists is growing up with rather simple ideas about programming. They are doing tutorials on creating graphical user interfaces with Java AWT, disguised as modules called object oriented programming. Java is hot, hence it is used to attract new students. If we really wanted to teach them about object orientation we would have considered using Smalltalk, Eiffel or Objective C. It's saddening to realize how many students fail to understand the concepts of inheritance and polymorphism. Surely they can recite some definition and come up with an example about animals, cats, and dogs. But applying them in real life situations takes more than that. It's even worse; try asking around why the application entry point in a Java program is static, and you'll see what I mean. Many might consider this an insignificant Java requirement, but not realizing that all non-static methods receive an implicit this pointer is missing a great deal of expression power. And this is one of many examples, so don't get me started on pointer arithmetic. 

This is only considering the crippled knowledge about some specific programming paradigm. The complete denial of other paradigms acknowledges the already narrow-minded approach to programming. What happened to Pascal, C or assembly programming? It seems they are treated as archaic rudiments from long gone times. True, they bear paradigms not used as much as they used to, but they also convey some important concepts that are beneficial even in today's situations. The same goes for logical, generic and functional programming which are treated as silly sidesteps from the common path of programming. I consider those without an interest in these sidesteps programmers on a dead end path. 

I do not consider myself a good programmer, but I do recognize one when I see one. Professors wonder why student-projects spend too much time in the implementation phase. Well, have they ever tried to merge some unrelated inconsistent and unstable code, where trivial things like comments, assertions or error handling are missing, let alone the more advanced requirements like exception and thread safety. We are told about proven software engineering practices like source documentation and commenting, consistent code styles, source-control, peer reviews, unit tests, etc. in only a single class during our five years of education. It's time professors start accepting only well-written code. 

I'd like to see computer science go back to what it originally did; studying data representations, algorithms, and their applications. A study in which programming is the respected art of writing algorithms which transform data to useful, valuable and exciting applications. 

Let's stop training uninterested students to become leaders for herds of Java code monkeys, just because corporate financing requires us to. If this too much too ask, then at least bring back functional programming in the Twente University curriculum. 

Jaap Suter, a final year computer science student, not letting his schooling interfere with his education. 